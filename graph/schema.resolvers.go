package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"fmt"
	"reflect"

	"github.com/LonelySakura/surely/graph/model"
	"github.com/google/uuid"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, author string, commentsEnabled *bool) (*model.Post, error) {
	enable := true
	if !reflect.ValueOf(commentsEnabled).IsNil() {
		enable = *commentsEnabled
	}
	newPost := model.Post{
		ID:              GenerateID(),
		Title:           title,
		Content:         content,
		Author:          author,
		CommentsEnabled: enable,
	}
	_, err := r.DB.Exec(ctx,
		"INSERT INTO posts (id, title, content, author, comments_enabled) VALUES ($1, $2, $3, $4, $5)",
		newPost.ID, newPost.Title, newPost.Content, newPost.Author, newPost.CommentsEnabled,
	)
	return &newPost, err
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, content string, author string, postid string, parentid string) (*model.Comment, error) {
	if len(content) >= 2000 {
		return nil, fmt.Errorf("ERROR: Comment is too long")
	}
	p := uuid.Nil.String()
	post, err := r.Query().Post(ctx, postid)
	if err != nil {
		return nil, fmt.Errorf("ERROR: Post not found")
	}
	if !post.CommentsEnabled {
		return nil, fmt.Errorf("ERROR: Comments are disabled on this post")
	}
	if parentid != "" {
		p = parentid
		var exists bool
		err := r.DB.QueryRow(ctx,
			"SELECT EXISTS(SELECT 1 FROM comments WHERE id = $1)",
			parentid,
		).Scan(&exists)
		if err != nil || !exists {
			return nil, fmt.Errorf("ERROR: Parent comment not found")
		}
	}

	newComment := model.Comment{
		ID:       GenerateID(),
		Content:  content,
		Author:   author,
		Postid:   postid,
		Parentid: p,
	}
	_, err1 := r.DB.Exec(ctx,
		"INSERT INTO comments(id, content, author, post_id, parent_id) VALUES($1, $2, $3, $4, $5)",
		newComment.ID, newComment.Content, newComment.Author, newComment.Postid, newComment.Parentid,
	)
	return &newComment, err1
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*model.Post, error) {
	rows, err := r.DB.Query(ctx, "SELECT id, title, content, author, comments_enabled FROM posts")
	if err != nil {
		return nil, err
	}
	var posts []*model.Post
	for rows.Next() {
		var p model.Post
		err = rows.Scan(&p.ID, &p.Title, &p.Content, &p.Author, &p.CommentsEnabled)
		if err != nil {
			return nil, err
		}
		posts = append(posts, &p)
	}
	return posts, nil
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	var p model.Post
	err := r.DB.QueryRow(ctx,
		"SELECT id, title, content, author, comments_enabled FROM posts WHERE id = $1",
		id,
	).Scan(&p.ID, &p.Title, &p.Content, &p.Author, &p.CommentsEnabled)

	if err != nil {
		return nil, fmt.Errorf("post not found")
	}
	return &p, nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, id string, limit *int32, offset *int32) ([]*model.Comment, error) {

	rows, err := r.DB.Query(ctx, `
		SELECT 
			id, 
			content, 
			author, 
			post_id, 
			parent_id
		FROM comments 
		WHERE post_id = $1 AND parent_id = $2
		LIMIT $3 OFFSET $4
	`, id, "00000000-0000-0000-0000-000000000000", limit, offset)
	if err != nil {
		return nil, err
	}
	var comments []*model.Comment
	for rows.Next() {
		var c model.Comment
		err = rows.Scan(&c.ID, &c.Content, &c.Author, &c.Postid, &c.Parentid)
		if err != nil {
			return nil, err
		}
		comments = append(comments, &c)
		comments = append(comments, r.commentTree(ctx, c.ID)...)
	}
	return comments, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
